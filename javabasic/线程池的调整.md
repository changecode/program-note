1、我们通过一个简单的服务器程序来展示线程在其中所起到的作用，一个简单的单线程web服务器程序
----
		ServersSocket lister = new ServerSocket(8080);
		try{
			while(true) {
				Socket socket = lister.accept();
				try{
					handlerRequest(socket);
				}catch(IOException e) {
					e.printStackTrace();
				}
			}
		}finally{
			lister.close();
		}
		//对请求做处理
		private static void handlerRequest(Socket socket) {
			BufferedReader in = new BufferedReader(new InputStream(socket.getInputStream()));
			OutputStream out = socket.getOutputStream();
			out.write(response.getBytes("UTF-8"));
		}
	
		以上代码，只能一个线程处理所有socket，如果同时多个请求的话，会出现处理很缓慢的情况。
		因此，提出了使用多线程的思想。

		尽管handlerRequest可能被IO操作阻塞，但CPU可能是空闲的，它可以处理更多的请求。
		public static class HandlerRequestRunnale implements Runnable {
			final Socket socket;

			public HandlerRequestRunnale(Socket _socket) {
				this.socket = _socket;
			}

			public void run() {
				handlerRequest(socket);
			}
		}

		//main
		ServerSocket lister = new ServerSocket();
			try{
				while(true) {
					Socket socket = lister.accept();
					new Thread(new HandlerRequestRunnale(socket).start());
				}
			}finally {
				lister.close();
			
			}	
		上面这段代码，accept是在一个单线程循环中被调用，当TCP连接建立，socket创建时，服务器
		就创建一个新的线程，这个新生的线程将执行和单线程模型中一样的handlerRequest。thread per request方式创建新线程的操作是昂贵的。所以通过一个简单的线程池来避免持续创建新线程
		限制最大线程数量。线程池跟踪所有线程，在线程数量达到上限的。它会创建新的线程，当有空闲线程时，会使用空闲线程。
		ServerSocket lister = new ServerSocket(8080);
		ExecutorService executor = Executors.newFixedThreadPool(4);
		while(true) {
			Socket socket = lister.accept();
			executor.submit(new HandlerRequestRunnable(socket));
		}
		lister.close();
		提交的任务将会被线程池中的线程执行，而不是通过新创建的线程执行。所有的请求都通过一个线程数量固定为4的线程池来完成。这个线程池限制并发执行的请求数量，从而限制了系统资源的使用
		当线程池中的线程都在工作时，ThreadPoolExecutor可能会使用一个队列来组织新到达的请求
		，直到线程池中有空闲的线程可以使用。newFixedThreadPool方法默认会创建一个没有长度限制的linkedlist。因此工作队列的长度是有意义的。
		public static ExecutorService newBoundedFixedThreadPool(int nThreads, int capacity) {
			return new ThreadPoolExecutor(nThreads, nThreads, 0L,TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnale>(capacity), new ThreadPoolExecutor.DiscardPolicy());
		}

		public static void boundedThreadPoolServerSocket() throws IOException {
			ServerSocket lister = new ServerSocket(8080);
			ExecutorService executor = new BounderFixedThreadPool(4,16);
			while(true) {
				Socket socket = lister.accept();
				executor.submit(new HandlerRequestRunnale(socket));
			}
		} 

	
			
