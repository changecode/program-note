类加载机制
----

Java虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型

类从被加载到虚拟机内存中开始，到卸载出内存为止，整个生命周期包含：加载、验证、准备、解析、初始化、使用、卸载七个阶段。其中验证、准备和解析三部分统称为连接。
加载、验证、准备、初始化和卸载五个阶段顺序是确定的，类的加载过程必须按照这个顺序来开始，而解析过程则不一定，它在某些情况下可以在初始化阶段后再开始

类的生命周期的每一个阶段通常都是相互交叉混合式进行，通常会在一个阶段执行的过程中调用或者激活另外一个阶段


类加载的时机
----

主动引用：一个类被主动引用之后会触发初始化过程(加载、验证、准备需在此之前开始)
* 遇到new、getstatic、putstatic或者invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条字节码指令最常见的java代码场景是：new实例化对象时，读取或者设置一个类的静态字段(被final修改、已在编译器把结果放入常量池的静态字段除外)时、以及调用一个类的静态方法时
* 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化
* 当初始化一个类的时候，如果发现其父类还没进行过初始化，这需要触发父类的初始化
* 当虚拟机启动时，用户需要指定一个执行的主类(包含main方法的类)，虚拟机会先初始化这个类
* 当使用jdk7+的动态语言支持时，如果java.lang.invoke.methodHandler示例最后的解析结果REFgetStatic REFpubStatic REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化

被动引用：一个类如果是被动引用的话，该类不会触发初始化过程
* 通过子类引用父类的静态字段，不会导致子类初始化。对于静态字段，只有直接定义该字段的类才会被初始化，因此当通过子类来引用父类中定义的静态字段时，只会触发父类的初始化，而不会触发子类的初始化
* 通过数组定义来引用类，不会触发此类的初始化
* 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化


类加载过程
----

1.加载

* 通过一个类的全限定名称来获取定义此类的二进制字节流
* 将这个字节流锁待办的静态存储结构转化为方法区的运行时数据结构
* 在Java堆中生成一个待办这个类的java.lang.class对象，作为方法区这些数据的访问入口

2.验证

验证的目的是为了确保class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能回有所不同，但大致都会完成以下四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符合引用验证

* 文件格式的验证：验证字节流是否符合class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区进行存储，后面的三个验证都是基于方法区的存储结构进行的
* 元数据验证：对类的元数据信息进行语义校验(对类中的各数据类型进行语法校验)，保证不存在符合Java语法规范的元数据信息
* 字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为
* 符号引用验证：发生在虚拟机将符号语言转化为直接引用的时候，主要是对类自身以外的信息(常量池中的各种符号引用)进行匹配性校验

3.准备

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配

* 这时候进行内存分配的仅包含类变量(static)，而不包含实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中
* 这里所设置的初始化通常情况下是数据类型默认的零值(0 0L null false等)而不是被在Java代码中被显式地赋予的值


4.解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程

* 符号引用：符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，符号引用于虚拟机实现的内存布局无关，引用的目标并不一定已经在内存中
* 直接引用：直接引用可以是直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般都不相同，如果有了直接引用，那引用的目标必定已经在内存中存在。
	* 类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型引用，从而进行不同的解析
	* 字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有则查找结束；如果没有则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束
	* 类方法解析：对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的类还是接口的步骤，而且对类方法的匹配搜索，是先试试父类，再搜索接口
	* 接口方法解析：与类方法解析步骤类似，只是接口不会有弗雷，因此，只递归向上父接口就行了

5.初始化

类初始化阶段是类加载过程中最后一步，前面的类加载过程中，除了加载阶段用户应用程序可以通过自定义类家长群参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码
初始化阶段是执行类构造器<clinit>()方法的过程
	* <clinit>()方法时由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句并产生的，编译器收集的顺序由语句在源文件中出现的顺序所决定
	* <clinit>()方法与类的构造函数不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的()方法执行之前，父类的()方法以及执行完毕，因此在虚拟机中第一个执行的()方法的类一定是java.lang.Object
	* 由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作
	* <clinit>()方法对应类或者接口来说并不是必需的，如果一个类中没有静态语句块也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法
	* 接口中可能会有变量赋值操作，因此接口也会生成<clinit>()方法。但是接口和类不同，执行接口的linit方法不需要先执行父接口的clinit方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化也不会执行接口的clinit方法
	* 虚拟机会保证一个类的clinit方法在多线程环境中被正确的加锁和同步。如果有多个线程去同时初始化一个类，那么只会有一个线程去执行这个类的clinit方法，其他线程都需要阻塞等待，直到活动线程执行clinit方法完毕。如果在一个类的clinit方法中有耗时很长的操作，那么久可能造成多个进程阻塞


双亲委派模型
----

定义：某个特定的类加载器在接到加载类的请求时，首先将加载认为委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载

JVM预定义三种类型类加载器
* 启动(Bootstrap)类加载器：是用Native代码实现的类装入其，负责将lib下面的类库加载到内存中。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所有不允许直接通过引用进行操作
* 标准扩展(Extension)类家长群：是由ExtClassLoader实现的，负责将/lib/ext或者由系统变量java.ext.dir指定位置中的类库加载到内存中。开发者可以直接用准备扩展类加载器
* 系统(system)类加载器：由AppClassLoader实现，负责将系统类路径(classpath)中指定的类库加载到内存中。开发者可以直接使用系统类加载器


	