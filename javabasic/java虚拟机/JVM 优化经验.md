摘录于网上
===

Java虚拟机有自己完善的硬件架构，如处理器、堆栈、器存取等，还具有相应
的指令系统。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需
生成在Java虚拟机上运行的目标代码(字节码)，就可以在多种平台上不加修改
地运行。Java虚拟机在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。 本文针对jdk7 hotspot java虚拟机


用一个例子来开篇
====

假设你是一个普通的Java对象，出生在Eden区，在Eden区有许多和你差不多的
小兄弟、小姐妹，可以把Eden区当成幼儿园，在这个幼儿园里大家玩了很长
时间。Eden区不能无休止地放你们在里面，所以当年纪稍大，你就要被送到
学校去上学，这里假设从小学到高中都称为Survivor区。开始的时候你在Surviv
or区路面划分出来的From区，读到高年级了，就进入了Survivor区的To区，中间
由于学习成绩不稳定，还经常来回折腾。直到你18岁的时候，高中毕业了，该去
社会闯闯了。于是你就去了年老代，年老代里面人也很多。在年老代里，你生活
了20年(每次GC加一岁)，最后死亡，被GC回收。你在年老代里遇到了一个同学
他以及他的家族永远不会死，那么他们就生活在永生代。


如何将新对象预留在年轻代
====

由于Full GC的成本高于Minor GC，因此某些情况下需要尽可能将对象分配在
年轻代。虽然在大部分情况下，JVM会尝试在Eden区分配对象，但是由于空间
紧张等问题，很可能不得不将部分年轻对象提前向年老代压缩。因此，在JVM
参数调优时可以为应用程序分配一个合理的年轻代空间，以最大限度避免新对象
直接进入年老代的情况发生。一般来说，SUrvivor区的空间不够或者占用量
达到50%时，就会使对象进入年老代


如何让大对象进入年老代
====

在大部分情况下都会选择将对象分配在年轻代。但是，对于占用内存较多的
打对象而言，选择就不是这样的。因为大对象出现在年轻代很可能扰乱年轻代
GC，并破坏年轻代原有的对象结构。因为尝试在年轻代分配大对象，很可能导致
空间不足，为了有足够的空间容纳大对象，JVM不得不将年轻代中的年轻对象
挪到年老代。因为大对象占用空间多，所以可能需要移动大量小的年轻对象进入
年老代对象结构的完整性。这样可以提高GC的效率。如果一个大对象同是又是一
各短命的对象，假设这种情况出现很频繁，那对于GC来说就是一场灾难。原本应该用于存放永久代对象的年老代，被短命的对象塞满，这也意味着对堆空间进行
了洗牌，扰乱了分代内存回收的基本思路。因此，应该尽可能避免使用短命的大
对象，可以使用参数-XX:PetenureSizeThreshold设置大对象直接进入年老代的
阈值。当对象的大小超过这个值时，将直接在年老代分配。参数-XX:PetenureSi
zeThreshold只对串行收集器和年轻代并行收集器有效，并行回收集器不识别这
个参数


设置对象进入年老代的年龄
====

堆中的每一个对象都有自己的年龄。一般情况下，年轻对象存放在年轻代，年
老对象存放在年老代。为了做到这点，虚拟机为每个对象都维护一个年龄。
如果对象在Eden区，经过一次GC后依然存货，则呗移动到了Survivor区中，对象
年龄加1。以后，如果对象每经过一次GC依然存活，则年龄再加1.当对象年龄
达到阈值就移入年老代，称为老年对象。这个阈值的最大值可以通过参数
-XX:MaxTenuringThreshold来设置，默认值时15.虽然这个值可能是15或者更大
但这不以为着新对象非要达到这个年龄才能进入年老代。 实际上，对象实际
进入年老代的年龄是虚拟机在运行时根据内存使用情况动态计算的，这个参数
指定的是阈值年龄的最大值


稳定的Java堆与动荡的Java堆
====

一般来说，稳定的堆大小对垃圾回收是有利的。获得一个稳定的堆大小的方法
是使用-Xms和-Xmx的大小一致，即最大堆和最小堆(初始堆)一样。如果这样
设置，系统在运行时堆大小理论上是恒定的，问题的堆空间可以减少GC的次数
因为。很多服务端应用都会将最大堆和最小堆设置为相同的数值。但是，一个
不稳定的堆并非毫无用处。 稳定的堆大小虽然可以减少GC次数，但同时也增加
了每次GC的时间。让堆大小在一个区间中震荡，在系统不需要使用大内存时，
压缩堆空间，使用GC应对一个较小的堆，可以加快单次GC的速度。

-XX:MinHeapFreeRatio 参数用来设置堆空间最小空闲比例，默认值时40.当堆
空间的空闲内存小于这个数值时，JVM便会扩展堆空间

-XX:MaxHeapFreeRatio 设置堆空间最大空闲比例， 默认值时70.当堆空间的
空闲内存大于这个数值时，便会压缩堆空间，得到一个较小的堆。

当-Xmx和-Xms相等时，-XX:MinHeapFreeRatio  -XX:MaxHeapFreeRatio 
二个参数无效


增加吞吐量提升系统性能
====

吞吐量优先的方案将会尽可能减少系统执行垃圾回收的总时间，故可以考虑
关注系统吞吐量的并行回收收集器。在拥有高性能的计算机上，进行吞吐量
优先优化，可以使用参数 java –Xmx3800m –Xms3800m –Xmn2G –Xss128k 
–XX:+UseParallelGC –XX:ParallelGC-Threads=20 –XX:+UseParallelOldGC

–Xmx380m –Xms3800m：设置 Java 堆的最大值和初始值。一般情况下，为了避免堆内存的频繁震荡，导致系统性能下降，我们的做法是设置最大堆等于最小堆。假设这里把最小堆减少为最大堆的一半，即 1900m，那么 JVM 会尽可能在 1900MB 堆空间中运行，如果这样，发生 GC 的可能性就会比较高

-Xss128k：减少线程栈的大小，这样可以使剩余的系统内存支持更多的线程

-Xmn2g：设置年轻代区域大小为 2GB

–XX:+UseParallelGC：年轻代使用并行垃圾回收收集器。这是一个关注吞吐量的收集器，可以尽可能地减少 GC 时间

–XX:ParallelGC-Threads：设置用于垃圾回收的线程数，通常情况下，可以设
置和 CPU 数量相等。但在 CPU 
数量比较多的情况下，设置相对较小的数值也是合理的

–XX:+UseParallelOldGC：设置年老代使用并行回收收集器


使用非占有的垃圾回收器
=====



为了减低应用软件的垃圾回收时的停顿，首先考虑的是使用关注系统停顿的
CMS回收器，日此，为了减少Full GC次数，应尽可能将对象预留在年轻代，
因为年轻代Minor GC的成本远远小于年老代的Full GC

java –Xmx3550m –Xms3550m –Xmn2g –Xss128k –XX:ParallelGCThreads=20
–XX:+UseConcMarkSweepGC –XX:+UseParNewGC –XX:+SurvivorRatio=8 
–XX:TargetSurvivorRatio=90  –XX:MaxTenuringThreshold=31

-XX:ParallelGCThreads=20  设置20个线程垃圾回收

-XX:+UseParNewGC  年轻代使用并行回收器

-XX:+UseConcMarkSweepGC 年老代使用CMS收集器降低停顿

--XX:SurvivorRatio 设置Eden区和Survivor区的比例为8:1. 稍大的Survivor
空间可以提高在年轻代回收生命周期较短的对象的可能性，如果Survivor不
够大，一些短命的对象可能直接进入年老代，这对系统来说不利的

–XX:TargetSurvivorRatio=90：设置 Survivor 区的可使用率。这里设置为 
90%，则允许 90%的 Survivor 空间被使用。默认值是 50%。故该设置提高了
Survivor 区的使用率。当存放的对象超过这个百分比，则对象会向年老代压
缩。因此，这个选项更有助于将对象留在年轻代

–XX:MaxTenuringThreshold：设置年轻对象晋升到年老代的年龄。默认值是
15 次，即对象经过 15 次 Minor GC 依然存活，则进入年老代。这里设置为
31，目的是让对象尽可能地保存在年轻代区域