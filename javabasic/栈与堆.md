栈
	栈是为执行线程留出的内存空间。当函数被调用的时候，栈顶为局部变量预留块。当函数执行完毕，块就没有用了，可能在下次的函数调用的时候再被使用。栈通常用后进先出的方式预留空间；因此最近的保留块通常最先被释放。这样做可以使跟踪堆栈变得简单；从占中释放块只不过是指针的偏移而已。

	1、栈经常与sp(stack pointer)寄存器一起工作，最初sp指向栈顶(栈的高地址)
	2、CPU用push指令来讲数据压栈，用pop指令来弹栈。当用push压栈时，sp值减少，当pop弹栈时，sp值增大。存储和获取数据都是CPU寄存器的值
	3、当函数被调用时，CPU使用特定的指令把当前的IP压栈，即执行代码的地址。CPU接下来将调用函数地址赋给IP，进行调用。当函数返回时，旧的IP被弹栈，CPU继续去函数调用之前的代码
	4、当进入函数时，sp向下扩展，扩展到确保为函数的局部变量留足够大小的空间。如果函数中有一个32-bit的局部变量会在栈中留够四字节的空间。当函数返回时，sp通过返回原来的为准来释放空间。
	5、如果函数有参数的话，在函数调用之前，会将参数压栈。函数中的代码通过sp的当前为准来定位参数并访问它们。
	6、函数嵌套调用和使用魔法一样，每一次新调用的函数都会分配函数参数，返回值地址、局部变量空间、嵌套调用的活动记录都要被压入栈中。函数返回时，按照正确方式的撤销。
	7、栈要收到内存块的限制，不断的函数嵌套/为局部变量分配太多的空间，可能回导致栈溢出。当栈中的内存区域都已经使用完之后继续向下写(低地址),会触发一个CPU异常。这个异常接下来会通过语言的运行时转换成各种类型的栈溢出异常。

堆
	为动态分配预留的内存空间，和栈不一样，从堆上分配和重新分配块没有固定模式；可以在任何时候分配和释放它。这样使得跟踪哪部分堆已经被分配和被释放变得复杂。 许多定制的堆分配策略用来为不同的使用模式下调整堆的性能。

	1、堆包含一个链表来维护已用和空闲的内存块。在堆上新分配内存是从空闲的内存块中找到一些满足要求的合适块。这个操作会更新堆中的块链表。这些元信息也存储在堆上，经常在每个块的头部一个很小区域
	2、堆的增加新块通常从低地址向高地址扩展。因此可以认为堆随着内存分配而不断的增加大小。如果申请的内存大小很小的话，通常从底层操作系统中得到比申请大小要多的内存
	3、申请和释放许多小的块可能回产生如下状态： 在已用块之间存在很多小的空间块。进而申请大块内存失败，虽然空闲块的总和足够，但是空闲的小块是零散的，不能满足申请的大小。
	4、当旁边有空闲块的已用块被释放时，新的空闲块可能会与相邻的空闲块合并为一个大的空闲块，这样可以有效的减少堆碎片的产生。

	