1、java.lang.Thread类的一个实例

2、线程的执行：
----
使用java.lang.Thread类或者java.lang.Runnable接口编写代码来定义、实例化和启动新线程。一个Thread类实例只是一个对象，像Java中的任何其他对象一样，具有变量和方法，生死在堆上。Java中，每个线程都有一个调用栈，即使不在程序中创建任何新的线程，线程也在后台运行着。一个Java应用总是从main方法开始运行，main方法运行在一个线程内，称为主线程。 一旦创建一个新的线程，就产生一个新的调用栈。
	
线程分为二类：
用户线程、守护线程:  当所有用户线程执行完毕的时候，JVM自动关闭。但是守护线程却不独立与JVM，守护线程一般是由操作系统或者用户自己创建的。

3、启动线程
----
在线程的Thread对象调用start方法，而不是run或者别的方法。 在调用start方法之前，线程处于新状态中，新状态指有一个Thread对象，但还没有一个真正的线程。 在调用start方法之后，发生了一系列复杂的事情。启动新的执行线程；该线程从新状态转移到可运行状态；当该线程获得机会时，其目标run方法将运行。
		public class TestThread extends Thread { 
			public TestThread(String name) {
				super(name);
			}

			public void run() {
				for(int i=0; i<10; i++){
					System.out.println(this.getName() + i);
				}
			}

			public static void main(String[] args) {
				Thread t1 = new TestThread("aaa");
				Thread t2 = new TestThread("bbb");
				t1.start();
				t2.start();
			}

		}		

***注意点***

1、线程的名字，一个运行中的线程总是有名字的，名字有二个来源，一个是虚拟机自己给的名字，一个是自定义的名字。在没有指定线程名字的情况下，虚拟机总会为线程指定名字，并且主线程的名字总是main，非主线程的名字不确定	

2、线程都可以设置名字，也可以获取线程的名字，连主线程也不例外

3、获取当前线程对象的方法：Thread.currentThread();

4、每个线程都将穷，每个线程都将运行直到完成。一系列线程以某种顺序启动并不意味着将按该顺序执行。对于任何一组启动的线程来说，调度程序不能保证其执行次序，持续时间也无法保证。

5、当线程目标run方法结束时该线程完成

6、一旦线程启动，它就永远不会再重新启动。只有一个新的线程可以被启动，，并且只能一次。一个可运行的线程或死线程可以被重新启动

7、线程的调度室JVM的一部分，在一个CPU的机器上，实际上一次只能运行一个线程。一次只有一个线程栈执行。JVM线程调度程序决定运行哪个处于可运行状态的线程。 众多可运行线程中的某一个会被选中作为当前线程，可运行线程被选择运行的顺序是没有保障的。

8、尽管通常采用队列形式，但这是没有保障的。队列形式是指当一个线程完成一轮时，它移到可运行队列的尾部等待，知道它最终排队到该队列的前端为止，它才能被再次选中。事实上，我们把它称为可运行池而不是一个可运行队列，目的是帮助认识线程并不都是以某种有保证的顺序排队
