1、线程的状态转换是线程控制的基础,可分为五大状态：生、死、可运行、运行、等待\阻塞。
----

1)新状态： 线程对象已经创建，还没在其上调用start方法

2)可运行状态：当线程有资格运行，但调度程序还没有把它选定为运行线程时线程所处的状态。当start方法调用时，线程首先进入可运行状态，在线程运行之后或者从阻塞、等待或者睡眠状态回来后，也返回到可运行状态

3) 运行状态：线程调度程序可从运行池中选择一个线程作为当前线程时所处的状态

4)等待\阻塞\睡眠：线程仍旧是活的，但是当前没有条件运行。

5)死亡态：当线程的run方法完成时就认为它死去。这个线程对象也想是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生
2、阻止线程执行
----

1)睡眠
Thread.sleep(long millis)和Thread.sleep(long millis, int nanos)静态方法强制当前正在执行的线程休眠(暂停执行)，以减慢线程。当线程睡眠时，它入睡在某个地方，在苏醒之前不会放到可运行状态。当睡眠时间到期，则返回到可运行状态。

线程睡眠的原因：线程执行太快，或者需要强制进入下一轮

注意：
A、线程睡眠时帮助所有线程获得运行计划的最好方法
B、线程睡眠到期自动苏醒，并返回到可运行状态，不是运行状态。sleep中指定的时间是线程不会有哪些的最短时间，因此，sleep方法不能保证该线程睡眠到期后就开始执行
C、sleep是静态方法，只能控制当前正在执行的线程
		public class SleepThread extends Thread {
			
			public void run() {
				for(int i=0; i<10; i++) {
					if((i % 3) == 0) {
						System.out.println("========" + i);
					}
					try{
						Thread.sleep(1000);
						}catch(Exception e){

					}
				}
			}
		}

3、线程的优先级和线程让步yield
----
yield方法的作用：暂停当前正在执行的线程对象，并执行其他线程。线程总是存在优先级，优先级范围在1-10之间。JVM线程调度程序是基于优先级的抢先调度机制。在大多数情况下，当前运行的线程优先级将大于或等于线程池中任何线程的优先级。但这仅仅是大多数情况。

当线程池中线程都具有相同的优先级，调度程序的JVM实现自由选择它喜欢的线程。这时候调度程序的操作由二种可能：一是选择一个线程运行，直到它阻塞或者运行完成为止。二十时间分片，为池内的每个线程提供均等的运行机会。
		Thread t = new TestThread(); t.setPriority(8); t.start();线程默认优先级为5

Thread.yield：让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。

4、join方法
----
	
Thread的非静态方法join让一个线程B加入到另外一个线程A的尾部，在A执行完毕之前，B不能工作。另外，join方法还有带超时限制的重载版本，例如t.join(5000)则让线程等待5000毫秒，如果超过这个时间，则停止等待，变为可运行状态。

除了上诉三种让线程离开运行状态方法，还有几种方法使线程离开运行状态

A、线程的run方法完成

B、在对象上调用wait方法(不上线程上调用)
	
C、线程不能在对象上获得锁，			

D、线程调度程序可以决定当前预先状态移动到可运行状态，以便让另一个线程获得运行机会，而不需要任何理由	