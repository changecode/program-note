concurrent同步框架
===

需求
====

功能
=====
同步器一般包含两种方法，一种是acquire，另一种是rele
ase。acquire操作阻塞调用的线程，直到或除非同步状态
允许其继续执行。而release操作则是通过某种方式改变
同步状态，使得以或多个被acquire阻塞的线程继续执行

每一个同步器都支持：1、阻塞和非阻塞同步 2、 可选的
超时设置，让调用者可以放弃等待  3、通过中断实现的
任务取消，通常是分为两个版本，一个acquire可取消，而
另一个不可以

同步器的实现根据其状态十分独占而有所不同。独占状态
的同步器，在同一时间只有一个线程可以通过阻塞点，而
共享状态的同步器可以同时有多个线程在执行。一般锁的
实现类往往只维护独占状态，但是，例如计数信号量在
数量许可的情况下，允许多个线程同时执行。JUC包里还
定义了condition接口，用于支持管程形式的await/signal
操作，这些操作与独占模式的lock类有关，且condition的
实现天生就和其关联的lock类紧密相关

性能
=====

这里主要的性能目标是可伸缩性，即在大部分情况下，即
使或特别同步器有竞争的情况下，稳定地保证其效率。在
理想的情况下，不管有多少线程正试图通过同步点，通过
同步点的开销都应该是个常量。在某一线程被运行通过
同步点但还没有通过的情况下，使其消耗的总时间最少。

实现同步器的这些目标包含了两种不同的使用类型。大部
分应用程序是最大化其总的吞吐量，容错性，并且最好保
正尽量减少饥饿的情况。然而，对应那些控制资源分配的
程序来说，更重要是去维持多线程读取的公平性，可言接
守较差的总吞吐量。

设计与实现
====

同步器背后的基本思想非常简单。acquire操作如下：
while(synchronized state not allow acquire) {
	enqueue current thread if not already queued;
	possibly block current thread;
}
dequeue current thread if it was queued;

release操作
update synchronization state;
if(state may permit a blocked thread to acquire)
	unblock one or more queued threads;
为了实现上述操作，需要厦门三个基本组件的相互协作
1、同步状态的原子性管理
2、线程的阻塞与解除阻塞
3、队列的管理

同步状态
=====

AQS类使用单个int(32位)来保存同步状态，并暴露出
getstate、setState以及compareAndSet操作来读取和更新
这个状态。这些方法都依赖于JUC.atomic包的支持。这个
包提供了兼容volatile在读和写上的语义。将同步状态限
制32位的整形是处于实践上的考量。虽然也有64位的long
字段的原子性操作，但这些操作在很多平台上还是使用内
部锁的方式来模拟实训的，这回使得同步器的性能可能不
会很理想。

基于AQS的具体实现类必须根据暴露出的状态相关的方法
定义tryAcquire和tryRelease方法，以控制acquire和rele
ase操作。当同步状态满足时，tryAcquire方法返回true
而当新的同步状态允许后续acquire时，tryRelease方法也
必须返回true

阻塞
=====
阻塞线程和解除线程阻塞都是基于java内置管理，没有其
他非基于Java内置管理的API可以用来创建同步器。唯一
可以选择的是Thread.suspend和thread.resume但是他们
都无法解决竞态问题，所以也没法用：当一个非阻塞的线
程在一个正准备阻塞的线程调用suspend前调用了resume。
这个resume操作将不会有什么效果

队列
=====

为了维护适当的顺序，队列节点状态变量中的一个位记录
了该节点是否已经(或正在)被转移。唤醒和取消相关的代
码都会尝试用compareAndSet修改这个状态。如果某次
signal操作修改失败，就会转移队列中的下一个节点。
如果某次取消操作修改失败。就必须终止此次转移，然后
等待重新获得锁。后面的情况采用了一个潜在的无限的
自旋等待。在节点成功的被插到队列之前，被取消的等待
不能重新获得锁，所以必须自旋等待CLH队列插入被唤醒
线程成功执行，这里极少需要自旋，且自旋使用Thread.
yield来提示应该调度某一其他线程。

用法
====

所有java.util.concurrent包中的同步器都声明了一个
私有的继承了AbstractQueuedSynchronized的内部类，并
且把所有同步方法都委托给这个内部类。这样各个同步器
的公开方法就可以使用适合自己的名称。 像互斥锁这样
性能敏感的东西也打算通过委托和虚方法结合的方式来
定义。然而，这正是现代动态编译器一直在重点研究的
面向对象设计结构