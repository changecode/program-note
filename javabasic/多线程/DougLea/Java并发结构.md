java并发结构
===

线程
====
线程是一个独立执行的调用序列，同一个进程的线程在
同一时刻共享一些系统资源(比如文件句柄等)也能访问
同一个进程创建的对象资源(内存资源). java.lang.
Thread对象负责统计和控制这种行为。

每个程序都至少拥有一个线程即作为Java虚拟机(jvm)
启动参数运行在主类main方法的线程。在Java虚拟机初
始化过程中也可能启动其他的后台线程。这种线程的数
目和种类因JVM的事项而异。然而所有用户级线程都是
显式被构造并在主线程或者是其他用户线程中被启动。

构造方法
=====

Thread类中不同的构造方法接受如下参数的不同组合

1、一个Runnable对象，这种情况下,Thread.start方法将会调用对应Runnable对象的run方法，如果没有提供
Runnable对象，那么就会立即得到一个Thread.run的
默认实现
2、一个作为线程标识名的string字符串，该标识在跟
和调试过程中会非常有用，除此别无它用
3、线程组(ThreadGroup)用来放置新创建的线程，如果
提供的ThreadGroup不允许被访问，那么就会抛出一个
SecurityException

Thread类本身就已经实现了Runnable接口，因此，除了
提供一个用于执行的Runnable对象作为构造参数的办法
之外，也可以创建一个Thread的子类，通过重写其run
方法来达到同样的效果。然而，比较好的实践方法却是
分开定义一个Runnable对象并用来作为构造方法的参数
。将代码分散在不同的类中使得开发人员无需纠结于
Runnable和thread对象中使用的同步方法或同步块之间
内部交互。更普遍的是，这个分割使得对操作的本身与
其运行的上下文有着独立的控制。更好的是，同一个
Runnable对象可以同时用来初始化其他的线程，也可以用于构造一些轻量化的执行框架。通过继承thread类
实现线程的方式有一个缺点，无法再继承其他的类

Thread对象拥有一个守护标识属性，这个属性无法在构
法方法中被赋值，但是可以在线程启动之前设置该属性
的值。守护状态的作用非常有限，即使是后台线程在程
序退出的时候也经常需要做一些清理工作。

启动线程
=====

调用start方法会触发Thread实例以一个新的线程启动
其run方法，新线程不会持有调用线程的任何同步锁

当一个线程正常运行结束或者抛出某种未检测的异常，
线程就会终止。当线程终止之后，是不能被重新启动的
在同一个Thread上调用多次start方法会抛出InvalidTh
readStateException异常

如果线程已经启动但是还没有终止，那么调用isAlive
方法就会返回 true，即使线程由于某些原因处于阻塞
状态该方法依然返回true。 如果线程已经被取消 那么
调用其isAlive返回false，就因各Java虚拟机的实现而
异。 没有方法可以得知一个处于非活动状态的线程是
否已经被启动过了。另一点，虽然一个线程能够得知同
一个线程组的其他线程的标识，但是却无法得知自己是
由哪个线程调用启动的

优先级
=====

Java虚拟机为了实现垮平台的特性，Java语言在线程
调度与调度公平性上未作出任何的承若，甚至都不会
严格保证线程会被执行。但是Java线程却支持优先级
的方法，这些方法会影响线程的调度

每个线程都有一个优先级，分布在Thread_MIN_PRIORITY和Thread.MAX_PRIORITY之间(1-10)，默认情
况下，新创建的线程都拥有和创建它的线程相同的优先
级。main方法所关联的初始化线程拥有一个默认的优先
级，这个优先级是Thread.NORM_PRIORITY(5) 线程的
当前优先级可以通过getPriority方法获得。线程的优
先级可以通过setPriority方法来动态的修改，一个线
程的最高级由其所在的线程组限定

当可运行的线程数超过了可用的CPU数目的时候，线程
调度器更偏向于去执行那些拥有更高优先级的线程。
具体的策略因平台而异。 比如有些Java虚拟机实现总
是选择当前优先级最高的线程执行。有些虚拟机实现将
Java中的十个优先级映射到系统所支持的更小范围的
优先级上，因此，拥有不同优先级的线程可能最终被同
等对待。还有些虚拟机会使用老化策略(随着时间的增
长，线程的优先级逐级升高)动态调整线程优先级，另
一些虚拟机实现的调度策略会确保低优先级的线程最终
还是能够有机会运行。 设置线程优先级可以影响在同
一台机器上运行的程序之间的调度结果，但不是必须的

不同类任务再线程优先级设定上的通常约定
10  应急处理
7-9 交互相关，事件驱动
4-6 IO限制类
2-3 后台计算
1 仅在没有任何线程运行时运行的

控制方法
=====

只有很少几个方法可以用于垮线程交流

每个线程都有一个相关的Boolean类型的中孤单标识
在线程t上调用t.interrupt会将该线程的中断标识为
true，除非线程t正处于object.wait  thread.sleep
或者thrad.join

任何一个线程的中断状态都可以通过调用isInterrupt
ed方法来得到，如果线程已经通过interrupt方法被
中断，这个方法将会返回true

但是如果调用了thread.interrupted方法且中断标识
还是没有被重置，或者是线程处于wait sleep join
过程中，调用isInterrupted方法将会抛出异常。调用
t.join方法将会暂停执行调用线程，如果线程没能够
在指定的时间内完成，调用线程将重新得到控制权。
isAlive方法的实现原理，所以在一个还没启动的线程
上调用join方法时没有意义的

静态方法
=====

Thread类中的部分方法被设计只适用于当前正在运行
的线程，为强调这点，这些方法都被声明为静态的

thread.currentThread方法会返回当前线程的引用，
得到这个引用可以用来调用其他的非静态方法

Thread.interrupted方法会清除当前线程的中断状态
并返回前一个状态

Thread.yield方法只是建议Java虚拟机对其他处于
就绪状态的线程调度执行，而不是当前线程

线程组
=====

每一个线程都是一个线程组的成员。默认情况下，新
建线程和创建它的线程属于同一个线程组。线程组是
以树状分布的。当创建一个新的线程组，这个线程组
成为当前线程组的子组。getThreadGroup方法会返回
房钱线程所属的线程组


同步
====

对象与锁
=====

每一个object类及其子类的实例都拥有一个锁，其中
标量类型int float等不适对象类型，但是标量类型
可以通过其包装类来作为锁。单独的成员变量时不能
标明为同步的。锁只能用在使用了这些变量的方法上
，成员变量可以被声明为volatile，这个方式会影响
该变量的原子性，可见性以及排序性。 

类似的，持有标量变量元素的数组对象拥有锁，但是
其中的标量元素却不拥有锁。如果锁住了一个数组并
不代表其数组成员都可以被原子的锁定。也没有能在
一个原子操作中锁住多个对象的方法

同步方法同步块
=====

使用synchronized关键字，有两种语法结构：同步代
码块和同步方法。同步代码块需要提供一个作为锁的
对象参数，这就允许了任意方法可以去锁任一个对象
但是同步代码块使用最普通的参数却是this
synchronized void f() { /* body */ }
void f() { synchronized(this) { /* body */ } }
同步实例方法在其子类和父类中使用同样的锁，但是
内部类方法的同步却独立于其外部类，然而一个非静
态内部类方法可以通过下面这种方式锁住其外部类
synchronized(OuterClass.this)

等待锁与释放锁
=====

使用synchronized关键字遵循一套内置的锁等待-释放
机制。所有的锁都是块结构的。当进入一个同步方法
或同步块的时候必须获得该锁，而退出的时候必须释
放锁。

锁操作是建立在独立的线程上的而不是独立的调用
基础上。一个线程能够进入一个同步代码的条件是
当前锁未被占用或者当前线程已经占用了这个锁，
否则线程就阻塞。这就允许一个同步方法可以去直接
调用同一个锁管理的另一个同步方法，而不需要被
冻结

同步方法或同步块遵循机制有一个前提，那就是所有
的同步方法或同步块都是在同一个锁对象上。如果一
个同步方法正在执行中，其他的非同步方法也可以在
任何时候执行。也就是说，同步不等于原子性，但是同步机制可以用阿里实现原子性

静态变量/方法
=====

锁住一个对象并不会原子性的保护盖对象类或者其父
类的静态成员变量，而应该通过同步的静态方法或
代码块保证访问一个 静态的成员变量。静态同步使用
的是静态方法锁声明的类对象所拥有的锁。 类C的静
态锁可以通过内置的实例方法获取得到
synchronized(C.class) { /* body */ }

每个类对应的静态锁和其他的类没有任何的关系。通
国在子类中增加一个静态方法来试图保护父类中的静
态成员变量时无效的。应使用显式的代码块来代替
synchronized(getClass()) { /* body */ } // Do not use 这种方式，可能锁住的实际中的类，并不是需要保护
的静态成员变量所对应的类

Java虚拟机在类加载和类初始化阶段，内部获得并释
放类锁。

监视器
=====

正如每个对象都有一个锁一样，每一个对象同时拥有
一个由这些方法(wait notify notifyAll thread 
interrupt)管理的一个等待集合。拥有锁和等待集合
的实体通常称为监视器，任何一个对象都可以作为
一个监视器

对象的等待集合是由Java虚拟机来管理的，每个等待
集合上都持有在当前对象上等待但尚未被唤醒或是释
方的阻塞线程。各方法操作描述如下

wait
======

如果当前线程已经终止，那么这个方法会立即退出并
抛出Interruptedexception异常。否则当前线程就进
入阻塞状态

Java虚拟机将该线程放置在目标对象的等待集合中

释放目标对象的同步锁，但是除此之外的其他锁依然
由该线程持有。即使是在目标对象上多次嵌套的同步
调用，所持有的可重入锁也会完整的释放。这样，后
面恢复的时候，当前锁状态能够完全恢复

notify
======

java虚拟机从目标对象的等待集合中随意选择一个线
程，并从等待集合中移出，当等待集合中存在多个
线程时，并没有机制保证哪个线程会被选择到

线程必须重新获得目标对象的锁，直到有线程调用
notify释放该锁，否则线程会一直阻塞下去。如果
其他线程先一步获得了该锁，那么线程将继续进入
阻塞状态

线程从之前wait的点开始继续执行

notifyAll
======

与notify不同的时，它是通知所有线程

interrupt
======

如果在一个因wait而中断的线程上调用Thread.interr
upt方法，之后的处理机制相同，只是在重新获取这个
锁之后，该方法将会抛出一个InterruptedException
异常病区线程的中毒那标识被设为false，如果interrupt操作和notify操作在同一时间发生，那么不能保证
哪个操作先被执行

time wait
======

定时版本的wait方法，wait(long mesecs)和wait(long mesecs, int nanosecs)参数指定了需要在等待
集合中等待的最大时间值。如果在时间限制之内没有
被唤醒，将自动释放，除此之外，其他的操作都和无
参数的wait一样。 并没有状态能够表名线程正常唤醒
与超时唤醒之间的不同。需要注意的是，wait(0)与
wait(0,0)方法其实都具有特殊的意义，其相当于不限
时的wait方法， 由于线程竞争，调度策略以及定时器
粒度等方法的原因，定时等待方法可能回消耗任意的
时间
