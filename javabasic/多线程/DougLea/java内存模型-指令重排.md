Java内存模型_指令重排
===

指令重排
====

对于编译器的编写者来说，Java内存模型(JMM)主要是
由禁止指令重排的规则所组成的，其中包括了字段(
包括数组中的元素)的存取指令和监视器(锁)的控制指
令。


volatile与监视器
=====

JMM中关于volatile和监视器主要的规则可以被看作一
个矩阵。这个矩阵的单元格表示一些特定的后续关联指
令的情况下，指令不能被重排。在任何情况下，即使是
程序员错误的使用了同步读取，指令重排的结果也必须
达到最基本的Java安全要求。所有的显式字段都必须不
是被设定成0或null这样的预构造值，就是被其他线程
设值。这通常必须把所有存储在堆内存里的对象在其被
构造函数使用前进行归零操作，并且从来不对归零store指令进行重排。一种比较好的方式是在垃圾回收中对
回收的内存进行归零操作。


Final字段
=====

final字段的load和store指令相对于有锁的或者volati
le字段来说，就跟normal load和normal store的存取
是一样的，但是需要加入两条附加的指令重排规则

1、如果在构造函数中有一个final字段的store指令，
同时这个字段时一个引用，那么它将不能与构造函数外
后续可以让持有这个final字段的对象呗其他线程访问
的指令重排

2、一个final字段的初始化load指令不能与包含该字段
的对象的初始化load指令进行重排。

上述规则，要求对于带有final字段的对象的load本身
是synchronized volatile final或者来自类似的load
指令，从而确保Java程序员对于final字段的正确使用
并最终使构造函数中初始化的store指令和构造函数外
的store指令排序