同步与Java内存模型
===

序言
====

先看如下这个简单的Java类，该类中并没有使用同步
	
		final class SetCheck {
			private int a = 0;
			private long b = 0;

			void set() {
				a = 1;
				b = -1;
			}

			boolean check() {
				return ((b == 0) || (b == -1 && 
					a == 1));
			}
		}
如果是在一个串行执行的语言中，执行check方法永远不会
返回false，即使编译器，运行时和计算机硬件并没有按照
你所期望的逻辑来处理这段程序，该方法依然不会返回
false。在程序执行过程中，下面这些你所不能预料的行为
都是可能发生的
1 编译器可能会进行指令重排序，所以b变量的赋值操作可
能先于a变量。如果是一个内联方法，编译器可能更甚一步
将该方法的指令与其他语句进行重排序
2 处理器可能会对语句所对应的机器指令进行重排序之后
在执行，甚至并发地去执行
3 内存系统(由高速缓存控制单元组成)可能会对变量所对
应的内存单元的写操作指令进行重排序。重排之后的写
操作可能会对其他的计算/内存操作造成覆盖
4 编译器，处理器已经内存系统可能会让两条语句的机器
指令交错。比如在32位机器上，b变量的高位字节先被写入
，任何是a变量，紧接着才会是b变量的低位字节
5 编译器，处理器以及内存系统可能会导致两个变量的内
存单元在(如果有的话)连续的check调用之后的某个时刻
才更新，而以这种方式保存相应的值(如在CPU寄存器中)
仍会得到预期的结果(check不会返回false)	

在串行执行的语言中，只要程序执行遵循串行的语义，如
上几种行为就不会有任何影响。在一段简短的代码块中，
串行执行程序不会依赖于代码的内部执行细节，因此如上
的几种行为可以随意控制代码。这样就为编译器和计算机
硬件提供了基本的灵活性。基于此，在过去的数十年内
很多技术(CPU的流水线操作，多级缓存、读写平衡，寄存
器分配等等)应运而生，为计算机处理速度的大幅提升奠定
了基础。这些操作的类似串行执行的特性可以让开发人员
无线知道其内部发了什么

然而这些情况在并发编程中就完全不一样了，上面的代码
在并发过程中，当一个线程调用check方法的时候完全有可
能另外一个线程正在执行set方法，这种情况下check方法
就会将上面提到的优化操作过程暴露出来。如果上述任意
一个操作发生，那么check方法就有可能返回false。例如
check方法读取long类型的变量b的时候可能得到的既不是
0也不是-1，而是一个被写入一半的值。另一种情况，set
方法中的语句的乱序执行有可能导致check方法读取变量
b的值时候是-1，然而读取变量a时却依然是0

换句话说，不仅是并发执行会导致问题，而且在一些优化
操作(比如指令重排)进行之后也会导致代码执行结果和原
代码中的逻辑有所出入。由于编译器和运行时技术的成熟
及多处理器的普及，这种现象就变得越来越普遍。	

CPU的寄存器不呢干杯另一个CPU直接访问，这种模型必须
考虑到某个线程无法得知被另一个线程操作变量的值的
情况。这种情况下不仅仅存在于多处理器环境上，在单核
CPU环境里，因为编译器和处理器的不可预测的行为也可能
导致同样的情况

Java内存模型仅仅保证了代码指令与变量操作的有序性，
大多数规则都只是指出什么时候变量值应该在内存和线程
工作内存之间传输

1 原子性= 在Java内存模型中
这些规则需声明仅适用于实例变量和静态变量，也包括数
组元素，但不包括方法中的局部变量的内存单元的简单读
写操作
2 可见性= 一个线程执行的结果是另一个线程是可见的。
3 有序性= 某个线程的操作结果对其他线程来看是无序的


原子性
====

除了long型字段和double型字段外，Java内存模型确保访
问任意类型字段所对应的内存单元都是原子的。这包括引
用其他对象的引用类型的字段。此外，volatile long 和
vlolatile double 也具有原子性。

当在一个表达式中使用一个non-long或者non-double型字
段时，原子性可以确保你将获得这个字段的初始值或者某
个线程对这个字段写入之后的值；但不会是两个或更多线
程在同一时间对这个字段写入之后产生混乱的结果值，但
是原子性不能确保你获得的是任意线程写入之后的最新值
因此，原子性保证通常对并发程序设计的影响很小


可见性
====

只有在下列情况时，一个线程对字段的修改才能确保对另
一个线程可见：
一个线程释放一个锁之后，另一个读线程随后获取了同
一个锁。本质上，线程释放锁是会将强制刷新工作内存中
的脏数据到主内存中，获取一个锁将强制线程装载字段的
值。锁提供对一个同步方法或块的互斥性执行，线程执行
获取锁和释放锁时，所有对字段的访问的内存效果都是已
定义的。

注意同步的双重含义：锁提供高级同步协议，同时在线程
执行同步方法或块时，内存系统保存值的一致性。这说明
与顺序程序设计相比较，并发程序设计与分布式程序设计
更加类似。同步的第二个特性可以视为一种机制：一个线
程在运行已同步方法时，它将发送和或接收其他线程在
同步方法中对变量所做的修改

如果把一个字段声明为volatile类型，线程对这个字段
写入之后，在执行后续的内存访问之前，线程必须刷新
这个字段且让这个字段对其他线程可见。每次对volatile
字段的读访问，都要重新装载字段的值

一个线程首次访问一个对象的字段，它将读到这个字段的
初始值或被某个线程写入后的值。此外，把未构造完成的
对象的引用暴露给某个线程，这是一个错误的做法。在
构造函数内部开始一个新线程也是危险的，特别是这个类
可能被子类话。Thread.start有如下的内存效果：调用
start方法的线程释放锁，随后开始执行的新线程获取了
这个锁。如果在子类构造函数执行之前，可运行的超类
调用了new Thread(this).start()， 放run方法执行时，
对象很可能还没有完全初始化。同样，如果你创建且开始
一个线程T，这个线程使用了在执行start之后才创建的
一个对象x,你不能确信X的值字段值将能对线程T可见。
除非你把所有用到X的引用的方法做同步。如果可行的恶
化， 你可以在开始T线程之前创建X

线程终止时，所有写过的变量值都要刷新到主内存中。
比如一个线程使用Thread.join来终止另一个线程。那么
第一个线程肯定能看到第二个线程对变量值的修改。

注意，在同一个线程的不同方法之间传递对象的引用，永
远不会出现内存可见性问题。内存模型确保上述操作最终
会发生，一个线程对一个特定字段的特定更新，最终将会
对其他线程可见，但这个最终可能是很长一段时间。线程
之间没有同步时，很那保证对这个字段的值能在多线程
之间保存一直(指写线程对字段的写入理解对读线程可见)
特别是，如果字段不是volatile或没有通过同步来访问
这个字段，在一个循环中等待其他线程对这个字段的写入
，这种情况总是错误的。

在缺乏同步的情况下，模型还允许不一致的可见性。如果
得到一个对象的一个字段最新值，同时得到这个对象的其
它字段的过期的值。同样，可能读到一个引用变量的最新
值，但读取到这个引用暴露引用的对象的字段的过期值。
不管怎样，线程质之间的可见性并不总是失效，内存模型
仅仅是允许这种失效发生而言。因此，技术多个线程之间
没有使用同步，也不保证一定会方式内存可见性问题


有序性
====

有序性规则表现在以下两种场景：线程内和线程间

从某个线程的角度看方法的执行，指令会按照一种串行的
方式执行，已经应用于顺序编程语言

这个线程观察到其他线程并发地执行非同步的代码时，任
何代码都有可能交叉执行。唯一起作用的约束是：对于同
步方法，同步块已经volatile字段的操作仍维持相对有序

再次提醒，这些仅是最小特性的规则。具体到任何一个
程序或平台上，可能存在更严格的有序性规则。所以不能
依赖它们。

仅当某一时刻只有一个线程操作变量时，线程内的执行表
现为串行。当多线程同时运行在非同步的代码里进行公用
字段的读写时，会形成一种执行模式。在这种模式下，代
码会任意交叉执行，原子性和可见性会失效，以及产生
竞态条件。这时线程执行不再表现为串行


volatile
====

从原子性、可见性和有序性的角度分析，声明为volatile
字段的作用相当于一个类通过get/set同步方法保护普通
字段。

与使用synchronized相比，声明一个volatile字段的区别在于没有涉及到锁操作。但特别的是对volatile字段进行
++这样的读写操作不会被当做原子操作执行。  另外，有
序性可可见性仅对volatile字段进行一次读取或更新操作
起作用。声明一个引用变量为volatile，不能保证通过该
引用变量访问到非volatile变量的可见性。同理，声明一
哥数组变量为volatile不能保证数组内元素的可见性。vo
latile的特性不能在数组内传递，因为数组内里的元素
不能被声明为volatile

由于没有涉及到锁操作，声明volatile字段很可能比使用
同步的开销更低，但如果在方法内频繁访问volatile字段
很可能导致更低的性能，这时还不如锁住整个方法

volatile使用情况
1 该字段不遵循其他字段的不变式
2 对字段的写操作不依赖于当前值
3 没有线程违反预期的语义写入非法值
4 读操作不依赖其他非volatile字段的值