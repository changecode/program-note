volatile是轻量级的synchronized，因为它不会引起线程上下文的切换和调度
定义：
	允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。通俗的说就是一个变量如果被volatile修饰了，则Java可以确保所有线程看到这个变量的值是一致的，如果某个线程对volatile修饰的共享变量进行更新，那么其他线程可以立马看到这个更新，这就是所谓的线程可见性。

1、内存模型相关概念
	1） 操作系统语义
		计算机在运行程序时，每条指令都是在CPU中执行的，在执行过程中势必会涉及到数据的读写。运行运行的数据是存储在主内存中，这时会有一个问题，读写内存中的数据没有CPU中执行指令的速度快，如果任何的交互偶读需要与主内存打交道则会大大影响效率，所以就有了CPU高速缓存。CPU高速缓存为了某个CPU独有，只与该CPU运行的线程有关。但高速缓存也带了数据一致性问题，在程序运行中，会将运行所需要的数据复制一份到CPU高速缓存中，在进行运算时CPU不再直接从高速缓存中读写数据，只有当运行结束后才会将数据刷新到主内存中。 解决缓存一致性方案有二种：
			1） 通过在总线加lock锁的方式
			2） 通过缓存一致性协议
		第一种方式效率较低。第二种方案，缓存一致性协议，确保每个缓存中使用的共享变量的副本是一致的。其核心思想: 当某个CPU在写数据时，如果发现操作的变量时共享变量，则会通知其他CPU告知该变量的缓存是无效的，因此其他CPU在读取变量时，发现其无效会重新从主内存中加载数据。
	2）Java内存模型
		三个基本概念：原子性、可见性、有序性
		原子性：
			即一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。volatile无法保证符合操作的原子性
		可见性：当多个线程访问一个变量时，一个线程修改了这个变量的值，其他线程能够立即看到修改的值。
		有序性：程序执行的顺序按照代码的先后顺序执行，在Java内存模型中，为了效率是允许编译器和处理器对指令进行重排序，当然重排不会影响单线程的运行结果，但是对多线程会有影响。
	volatile可以保证线程可见性并提供了一定的有序性，但是无法保证原子性。在JVM底层volatile是采用内存屏障来实现的。这话代表了二层语义：1、保证可见性、不保证原子性 2、禁止指定重排序

		指定重排序：
			1、编译器重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序
			2、处理器重排序，如果不存在数据依赖性，处理器可以改变语句对应机器指定的执行顺序。
		指令重排序对单线程没有什么影响，但是会影响多线程的正确性。那么JVM是如何禁止重排序的呢？
		happens-before：
			1、同一个线程中，前面的操作happen-before后续的操作（即单线程按代码顺序执行，但是，在不影响在单线程环境执行结果的前提下，编译器和处理器可以进行重排序，这一规则无法保证编译重排和指令重排
			2、监视器上的解锁操作happen-before其后续加锁操作（synchronized规则）
			3、对volatile变量的写操作happen-before后续的读操作（volatile规则）
			4、线程的start方法happen-before该线程所有的后续操作（线程启动规则）
			5、线程所有的操作happen-before其他线程在该线程上调用join返回成功后的操作。
			6、如果a happen-before b, b happen-before c 则a happen-before c（传递性）

	观察加入volatile关键字和没有加入所生产的汇编代码发现，加入了volatile关键字时，会多出一个lock前缀指令，lock前缀指令其实就相当于一个内存屏障。内存屏障是一组处理指令，用来实现对内存操作的顺序限制。
	volatile适用场景：
		1、对变量的写操作不依赖当前值
		2、该变量没有包含在具体其他变量的不变式中		






