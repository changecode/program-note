分布式事务
---

特性：CAP
---

* Consistency：强一致性就是在客户端任何时候看到各节点的数据都是一致的

* Availability:高可用性就是在任何时候都可以读写

* Partition Tolerance:分区容错性是在忘了故障、某些节点不能通信的时候仍然继续工作。以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择


ACID
---

* Atomicity:原子性，一个事务中所有操作，要么全部完成，要么全部不完成，不会结束中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态

* Consistency:一致性，在事务开始之前和事务结束之后，数据库的完整性没有被破坏

* Isolation:隔离性，数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可言防止多个事务并发执行时由于交叉执行而导致数据的不一致

* Durability:持久性，事务处理结束后，对数据的修改就是永久的，即使系统故障也不会丢失 

数据一致性理解
---
* 强一致性:当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过得值。这种是对用户最友好的，就是用户上一次写了什么，下一次就能读到什么。这种实现需要牺牲可用性

* 弱一致性:系统并不保证后续进程或者线程的访问都会返回最新的更新过得值。系统在数据写入成功之后，不承若立即可用读到最新写入的值

* 最终一致性:系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。


常用分布式技术说明
---

* 本地消息表

基本设计思想就是将远程分布式事务拆分成一系统的本地事务。以转账的例子来描述：
第一步扣款1W，通过本地事务保证了凭证消息插入到消息表中
		Begin transaction
			update A set amount = amount - 10000 where userId = 1;
			insert into message(userId,price,status) values(1,10000,1);
		end transaction
		commit;
第二步，通知对方银行账户上加1W，通常采用两种方式：
	* 采用时效性高的MQ，由对方订阅消息并监听，有消息时自动触发事件
	* 采用定时轮询扫描的方式，去检查消息表的数据


* 消息中间件

* 非事务性的消息中间件
	还是上面提到的跨行转账，我们很难保证在扣款完成之后对MQ投递消息的操作就一定能成功。这样一致性就很难保证
		try{
			boolean result = dao.update(model);
			if(result) {
				mq.send(model);
			}
		}catch(Exception t) {
			rollback();
		}
	可能出现的情况：
	1、操作数据库成功，向MQ投递消息也成功
	2、操作数据库失败，不会向MQ中投递消息
	3、操作数据库成功，但是向MQ中投递消息时失败，向外抛出异常，刚刚执行数据库的操作将被回滚
	从上面分析的几种情况来说，基本上能保证发送者发送消息的可靠请。

	消费者端面临的问题	
	1、消息出列后，消费者对应的业务操作要执行成功。如果业务执行失败，消息不能失效或者丢失，需要保证消息与业务操作一直
	2、尽量避免消息重复消费。如果重复消费，也不能影响业务结果


* 支持事务的消息中间件(RocketMQ为例)

1、第一阶段，rocketmq在执行本地事务之前，会先发送一个prepared消息，并且会持有这个消息的地址
2、执行本地事务操作
3、确认消息发送，通过第一阶段拿到的地址去访问消息，并修改消息状态，如果本地事务成功，则修改状态为已提交，否则修改状态为已回滚
但是如果第三阶段的确认消息发送失败了怎么办？rocketmq会定期扫描消息集群中事务消息，如果发现了prepare状态的消息，它会向消息发送者确认本地事务是否已经执行成功，如果成功是回滚还是继续发送确认消息呢？rocketmq会跟进发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送和本地事务同时成功或同时失败


2PC(二阶段提交)
---

分布式事务最常用的解决方案就是二阶段提交，在分布式系统中，每个节点虽然可以知晓自己的操作是成功或者失败，却无法知道其他节点的操作是成功或失败。当一个事务垮多个节点是，为了保证事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有参与者节点的操作结果并最终指示这些节点是否要报操作结果进行真正的提交。
因此，二节点提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调组根据所有参与者的反馈情况决定各参与者是否要提交操作还终止操作

二个阶段指:第一阶段-准备阶段(投票阶段)第二阶段:提交阶段(执行阶段)

第一阶段
----

该阶段的主要目的在于打探数据库集群中的各个参与者是否能够正常的执行事务，步骤如下
1、协调者向所有参与者发送事务执行请求，并等待参与者反馈事务执行结果
2、事务参与者收到请求之后，执行事务，但不提交，并记录事务日志
3、参与者将自己事务执行情况反馈给协调者，同时阻塞等待协调者的后续指令

第二阶段
----

在第一个阶段协调者的询盘之后，各个参与者会回复自己事务的执行情况，这时存在三种可能
1、所有参与者回复能够正常执行事务
对于第一种情况，协调者将向所有的参与者发出提交事务的通知，步骤如下：
	1) 协调者向各个参与者发送commit通知，请求提交事务2
	2) 参与者收到事务提交通知之后，执行commit操作，然后释放占用的资源
	3) 参与者向协调者返回事务commit结果信息
2、一个多多个参与者回复事务执行失败
3、协调者等待超时
对于第二、三种情况，协调者认为参与者无法正常成功执行事务，为了整个集群数据的一致性，所以要向各个参与者发送事务回滚通知，步骤如下：
	1) 协调者向各个参与者发送事务rollback通知，请求回滚事务
	2) 参与者收到事务回滚通知之后，执行rollback，然后释放战友资源
	3) 参与者向协调者返回事务rollback结果信息

二阶段存在的问题，如果协调者出现问题，服务将不能正常使用；同步阻塞，效率低；可能存在不一致性


3PC(三阶段)
---

第一阶段(can_commit)
----	

该阶段协调者会去询问各个参与者是否能够正常执行事务，参与者根据自身情况回复一个预估值，相对于真正的执行事务，这个过程是轻量的，步骤如下：
1、协调者向各个参与者发送事务询问通知，询问是否可以执行事务操作，并等待回复
2、各个参与者依据自身状况回复一个预估值，如果预估自己能够正常执行事务就返回确定信息，并进入预备状态，否则返回否定信息

第二阶段(pre_commit)
----

本阶段协调者会跟进第一阶段的询盘结果采取相应操作，询盘结果主要有三种
1、所有参与者都返回确定信息
针对第一种情况，协调者会向所有参与者发送事务执行情况，步骤如下
	1 协调者向所有的事务参与者执行通知
	2 参与者收到通知后，执行事务，但不提交
	3 参与者将事务执行情况返回给客户端

2、一个或多个参与者返回否定信息
3、协调者等待超时
针对第二三中情况，协调者认为事务无法执行，于是想各个参与者发出abort通知，请求退出预备状态

第三阶段(do_commit)
----

如果第二阶段事务未中断，那么本阶段协调者将会依据事务执行返回的结果来决定提交或回滚事务，分为三种情况
1、所有参与者都会能注册执行事务
针对第一种情况，协调者向各个参与者发起事务提交请求，步骤如下：
	1 协调者向所有参与者发送事务commit通知
	2 所有参与者在收到通知之后执行commit操作，并释放占用资源
	3 参与者向协调者反馈事务提交结果

2、一个或多个参与者执行事务失败
3、协调者等待超时
第二三种情况，协调者认为事务无法正常执行，向参与者发送事务rollback通知