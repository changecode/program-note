常用分库分表全局主键策略
----

1、UUID 使用UUID作为主键是最简单的方法，但是缺点是UUID非常长，
除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能瓶颈

2、维护一个sequence表，表的结构类似 
		
		tablename varchar(30) not null
		nextid bigint(20) not null 
		primary key (tablename)
每当需要为某个表的新纪录生成ID时就从该表取出对应表的nextID，并将nextID加1后更新到数据库中以备下次使用。 缺点是所有插入任何都需要访问该表，该表很容易成为系统性能瓶颈，同时也存在单点问题，一旦该表数据库失效，整个应用将无法工作。也可以使用master-slave进行主从同步，但也只能解决单点问题，并不能解决读写比为1:1的访问压力问题

3、Flickr方案： 建立二台以上数据库ID生成服务器，每个服务器都有一张吉林各表当前ID的sequence表，但是sequence中ID增长的步长是服务器的数量，起始值依次错开，这样相当于吧ID生产散列到了每个服务器借点上。 例如 设置二台数据库ID生成服务器，那么就让一台sequence表的ID起始值为1，每次步长为2，另一台ID起始值为2，步长也为2，那么结果就是奇数的ID都在第一台服务器上生成，偶数的ID都从第二台服务器上生成，这样生成ID的压力均匀分散到二台服务器上，同时配合应用程序的控制，当一个服务器失效后，系统自动切换到另一个服务上获取ID，从而保证系统的容错


关于方案三，有几点细节：

1、Flickr的数据库ID生成服务器是专用服务器，服务器上只有一个数据库，数据库中表都是用于生成sequence的，这样说因为auto-increment-offset和auto-increment-increment这二个数据库变量时数据库实例级别的变量

2、Flickr的方案中表格中的stub字段只是一个char(1) not null存根字段，并非表名，因此，一般来说，一个sequence表只有一条记录。可以同时为多张表生成ID，如果需要表的ID是有连续的，需要为该表单独建立sequence表

3、方案使用mysql的last_insert_id函数，这也决定了sequence表只能有一条记录

4、使用replace into插入数据，利用MySQL自身的机制生成ID，因为需要ID按照设定的方式(初值和步长)来生成

5、select last_insert_id必须要于replace into语句在同一个数据库连接下才能得到刚刚插入的新ID，否则返回的值总是0、

6、sequence表使用的是mylasm引擎，以获取更高的性能。该引擎使用的是表级别的锁，对表的读写是串行的，因此不必担心在并发时二次读取会得到同一个ID，程序也不需要同步，每个请求的线程都会得到一个新的connection，不存在需要同步的共享资源、

7、可使用jdbc来实现对sequence表的操作


应用程序需要做的处理：

1、自动均衡数据库ID生产服务器的访问
2、确保在某个数据库ID生成服务器失效时将请求转发到其他服务器上执行
