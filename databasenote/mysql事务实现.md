MySQL事务实现
===

原子性
====

虽然事务具有原子性，但是原子性并不是只与
事务有关系。 由于操作并不具有原子性，并且
可以再分为多个操作，当这些操作出现错误或
抛出异常时，整个操作就可能不回继续执行下去
而已经进行的操作造成的副作用就可能造成数据
更新的丢失或错误。 
事务其实和一个草没有什么太大的区别，它是
一些了的数据操作的集合，如果事务不具备原子
性，那么久没办法保证同一个事务中的所有操作
都被执行或者未被执行了

回滚日志
====

想要保证事务的原子性，就需要在异常发生时，
对已经执行的操作进行回滚，而在MySQL中，恢复
机制是通过回滚日子实现的，所有事务进行的修
改都会先记录到这个回滚日志中，然后再对数据库
中的应对行进行写入

回滚日志除了能够在发生错误或者用户只需rollba
ck时提供回滚相关的信息，它还能够在整个系统
发生崩溃，数据库进程直接被杀死后，但该用户
再次启动数据库进程时，还能够离开通过查询
回滚日志将之前未完成的事务进行回滚，这也就
需要回滚日志必须先于数据持久化到磁盘上，是
我们需要先写日志后写数据库的主要原因

回滚日志并不能讲数据库物理地恢复到执行语句
或者事务之前的样子；它是逻辑日志，当回滚日志
被使用时，它指挥按照日志逻辑地将数据库这的
修改撤销掉看，可以理解为，我们在事务中使用
每一条insert对应一条delete,每一条update也对应一条相反的update语句

事务的状态
====

事务的状态只有三种:active commited failed
事务要不就在执行中，要不然就是成功或者失败
但是放大看的就不止三种，
active:事务的初始状态，表示事务正在执行
partially commited：在最后一条语句执行之后
failed:发现事务无法正常执行之后
aborted:事务被回滚并且数据库恢复到了事务进行
之前的状态之后
commited:成功执行整个事务

并行事务的原子性
====

当T1在执行的过程对用户1的数据进行读写，但是
没有见冠希哥的内容进行提交或回滚，在这时
T2对同样的数据进行了读操作并提交了事务；也
就是说T2依赖于T1，当T1由于一些错误需要回滚
时，因为要保证事务的原子性，需要对T2进行
回滚，但是由于我们已经提交了T2，所以我们没有
进行回滚操作。
所以，事务T1必须在T2提交前完成提交的操作
然而，当书屋的数量逐级增多时，整个恢复流程
也会变得越来越复杂，要从事务发生的错误中恢复
也不是一件那么容易的事情

持久性
====

如果数据被写入到数据库中，那么数据一定能够
被安全存储在磁盘上；而事务的持久性就体现在
一旦事务被提交，那么数据一定会被写入到数据
库中并持久存储起来。当事务已经被提交之后，
就无法再次回滚了，唯一能够撤回已经提交的事务
就是创建一个相反的事务对原操作进行补偿，这
也是事务持久性的体现之一

重做日志
====

与原子性一样，事务的持久性也是通过日志来
实现的，MySQL使用重做日志实现事务的持久化
重做日志由两部分组成，一是内存中的重做日志
缓冲区，因为重做日志缓冲区在内存中，所以
容易丢失，另一个就是磁盘上的重做日志文件，
持久的
当我们在一个事务中尝试对数据进行修改时，它
会先将数据从磁盘读入内存，并更新内存中缓存
的数据，然后生成一条重做日志并写入重做日志
缓存，但过十五真正提交时，MySQL会将重做日志
缓存中的内容刷新到重做日志文件，再讲内存中
的数据更新到磁盘上
在InnoDB中，重做日志都是以512字节的块的形式
进行存储的，同时以为块的大小与磁盘扇区大小
相同，所以重做日志的写入可以保证原子性，不会
由于机器端点倒追重做日志仅写入一半并留下
脏数据。 除了所有对数据库的修改会产生重做
日志，因为回滚日志也是需要持久存储的，它们
也会创建对应的重做日子，在发生错误后，数据
库重启时会从重做日志中找出未被更新到数据库
磁盘中的日志重新执行以满足事务的持久性

在数据库系统中，事务的原子性和持久性是由
事务日子保证的，在时限也就是上面提到的两种
日志，前者用于对事务的影响进行撤销，后者
在错误处理时对已经提交的事务进行重做，它们
保证两点
1、发生错误或者需要回滚的事务能够成功回滚
2、在事务提交后，数据没来得及写会磁盘就
宕机时，在下次重新启动后能够成功恢复数据