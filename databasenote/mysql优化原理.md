mysql逻辑架构
===

MySQL逻辑架构整体分为三层，最上层为客户端层，并非MySQL独有，诸如：连接
处理、授权认证、安全等功能均在这一层处理

MySQL核心服务在中间一层，包括查询解析、分析、优化、缓存、内置函数。所
有的跨存储引擎的功能也在这一层实现。 存储过程、触发器、视图等

最下为存储引擎，负责MySQL中的数据存储和提取。


MySQL查询过程
===

客户端/服务端通信协议
====

两者通信协议是半双工的。 在任一时刻，要不是服务器向客户端发送数据
要不就是客户端向服务器发送数据，这两个动作不能同时发送。一旦一端开始
发送消息，另一端要接受完整个消息才能响应它，无法将一个消息切成小块
独立发送，也无法进行流量控制。

客户端用一个单独的数据包将查询请求发送给服务器，所以当查询语句很长的
时候，需要设置max_allowed_packet参数。 但如果查询实在太大，服务器端
会拒绝接受更多数据并抛出异常

与之相反，服务器响应给用户的数据通常会很多，由多个数据包组成。但是当
服务器响应客户端请求时，客户端必须完整的接收整个返回结果，而不能简单
的只取前面几条结果，然后让服务器停止发送。因此，在实际开发中，减少通信
数据包的大小和数据是一个非常好的习惯，这也是查询避免使用星号原因之一


查询缓存
====

在解析一个查询语句钱，如果查询缓存是打开的，那么MySQL会检查这个查询
语句是否命中查询缓存中的数据。如果当前查询恰好命中查询缓存，在检查
一次用户权限后直接返回缓存中的结果。这种情况下，查询不会被解析，也不会
生成执行计划，更不会执行

MySQL将缓存存放在一个引用表(类型hashmap的数据结构). 通过一个哈希值索引
这个哈希值通过查询本身、当前要查询的数据库、客户端协议版本号等一些可
能影响结果的信息计算得来。 所以两个查询在任何字符上的不同，都会导致
缓存不会命中

如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL
库中的系统表。其查询结果都不会被缓存。 比如函数now或者current_date会
因为不同的查询时间，返回不同的查询结构，再比如包含current_user
或者Connecion_id的查询语句因为不同的用户返回不同的结果。

既然是缓存就会失效，那么什么失效。 MySQL查询缓存系统会跟踪查询中涉及
的每个表，如果这些表(数据或结构)发生变化，那么和这张表相关的所有缓存
数据都会失效。 正因为如此，在任何的写操作时，MySQL必须将对应表相关的
所有缓存都设置为失效。 如果查询缓存非常大或碎片很多，那么这个操作可能
带来很大的系统消耗。而且查询缓存对系统的额外消耗也不仅仅是在写操作，
读操作也不例外。 针对于此优化建议

1、用多个小表代替一个大表(不要过度设计)
2、批量插入代替循环单条插入
3、合理控制缓存空间大小，一般来说设置为几十MB比较合适
4、可以通过sql_cache和sql_no_cache来控制某个查询语句是否需要进行缓存

最后的忠告是不要轻易打开查询缓存，特别是写密集型应用。如果你实在是忍不住，可以将query_cache_type设置为DEMAND，这时只有加入SQL_CACHE的查询才会走缓存，其他查询则不会


语法解析和预处理
====

MySQL通过关键字将sql语句进行解析，并生成一颗对应的解析树。这个过程
解析器注意通过语法规则来验证和解析。

查询优化
====

经过前面的步骤生成的语法树被认为是合法的，由优化器将其转化成查询计划
多数情况下，一条查询可以有很多种执行方式，最后都返回相应的结果。优化
器的作用就是找到这其中最好的执行计划

MySQL认为的最优和我们想的不一样(我们希望执行时间尽可能断，但MySQL
只选择它认为成都小的，但成本小并不意味着执行时间短)等等

MySQL的查询优化器是一个非常复杂的部件，使用了非常多的优化策略来生成一
各最优的执行计划
1、重新定义表的关联顺序(多张表关联查询时，并不一定按照sql中指定的顺序
进行，但有方法可以指定关联顺序)
2、优化min和max函数
3、提前终止查询(limit)
4、优化排序

查询执行引擎
====

完成了解析和优化阶段之后，MySQL会生成对应的执行计划，查询执行引擎根据
执行计划给出的指令逐步执行得出结果。 整个执行过程的大部分操作均是通过
调用存储引擎实现的接口来完成， 这些接口被称为handler api。 查询过程中
每一张表由一个handler实例表示。实际上MySQL在查询优化阶段就为每一张表
创建了一个handler实例，优化器可以根据这些实例的接口来获取表的相关信息
，包括表的所有列名、索引统计信息等。存储引擎接口提供了非常丰富的功能
但其底层仅有几十个接口，这些接口像搭积木一样完成了一次查询的大部分操作

总结MySQL查询执行过程
=====

1、客户端向MySQL服务器发送一条查询请求
2、服务器首先检查查询缓存，如果命中，直接返回存储在缓存中的结果。
否则进入下一阶段
3、服务器进行sql解析、预处理、再由由优化器生成对应的执行计划
4、MySQL根据执行计划，调用存储引擎Api来执行查询
5、将结果返回给客户端，同时缓存查询结果


数据类型优化
===

常见误区如下:

1、同常来说把可为null的列改为not null不会对性能提升多少，如果只是
计划在列上创建索引，就应该将该列设置为not null
2、对整数类型指定宽度,比如int(11)没有什么作用， int使用32位(4个字节)
存储空间即表示范围已经确定，所以int(1)和int(20)对于存储和计算一样
3、unsigned表示不允许负值，大致可以使正数的上限提高一倍。比如tinyint
存储范围是-128-127，而unsigned tinyint存储的范围是0-255
4、timestamp使用四个字节存储空间，datetime使用八个字节存储空间。times
tamp只能表示1970-2038，比datetime表示范围小，而且timestamp的值因
时区不同而不同
5、schema的列不要太多。 原因是存储引擎的Api工作时需要在服务器层和
存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码
成各个列，这个转换过程代价是很高的。
6、大表alert table非常耗时，MySQL执行大部分修改表结果操作的方法是
使用新的结构创建一张空表，从旧表中查出所有的数据插入新表，然后再
删除旧表，尤其当内存不足而表又很大，而且还有很大索引的情况下，耗时久


视图
=====

语法  create view 视图名 as select 语句

好处:
1、简化查询语句
create view avgPrice as select cat_id,avg(shop_price) from goods gropy by cat_id;
select * from avgPrice

2、可以进行权限控制
把表的权限封闭，但是开放相应的视图权限，视图里只开放部分数据列
比如我们的goods商品表，我们不想让别人看到我们的销售价格，这时候我们就
可以把查看商品表的权限封闭，创建一张视图
create view showGoods as select goods_id,goods_name from goods;
不出现销售价格列就可以了

3、大数据分表时可以用到
News表
newsid  1,2,3,4...
news1,news2,news3,news4表
把一张表的数据分散到4张表里

可以用视图，把四张表形成一张视图
create view news as select * from news1 union select * from news2 
union ...
