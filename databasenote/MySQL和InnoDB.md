MySQL和InnoDB
===

数据库和实例
====

在MySQL中，实例和数据库往往都是一一对应的，
而我们无法直接操作数据库，而是要通过数据库
实例来操作数据库文件，可以理解为数据库实例是
数据库为上层提供的一个专门用于操作的接口

在Unix上，启动一个MySQL实例往往会产生两个
进程，mysqld就是真正的数据库服务守护进程，
而mysqld_safe是一个用于检查和设置mysqld启
动的控制程序，负责监控MySQL进程的执行，当
mysqld发生错误时 ，mysqld_safe会对其状态
进行检查并在合适的条件下重启

MySQL的架构
====

最上层用于连接、线程处理的部分；第二层包含
大多数MySQL的核心服务，包括对sql的解析、
分析、优化和缓存等功能，存储过程、触发器
和试图都是在这里实现的；而第三层就是MySQL
中真正负责数据的存储和提取的存储引擎
如：InnoDB MyISAM等，本文针对InnoDB分析

数据的存储
====

在整个数据库体系结构中，可以使用不同的存储
引擎来存储数据，而绝大数存储引擎都是以二
进制的形式存储数据

在InnoDB存储引擎中，所有的数据都被逻辑地
存放在表空间中，表空间(tablespace)是存储
引擎中最高的存储逻辑单位，在表空间的下面
又包括段(segement)、区(extent)、页(page)
同一个数据库实例的所有表空间都有相同的页
大小；末日情况下，表空间中的页大小都为16k
当然也可以通过改变innodb_page_size选项对
默认大小进行修改，需要注意的是不同的页大小
最终也会导致区大小的不同。在InnoDB存储引擎
中，一个区的大小最小为1MB，页的数量最少为
64个

如何存储表
====

mysql使用InnoDB存储表时，会将表的定义和
数据索引等信息分开存储，其中前者存储在.frm
文件中，候着存储在.idb文件中

.frm文件
=====

无论在mysql中选择了哪个存储引擎，所有的
MySQL表都会在硬盘上创建一个.frm文件，用来
描述表的格式或者说定义 .frm文件的格式在不
同的平台都是相同的。create table test_frm
{column1 char(5), column2 integer}; 以上
代码创建表时，会在磁盘上的datadir文件夹中
生成一个test_frm.frm文件，这个文件中就包含
表结构相关的信息

.ibd文件
=====

InnoDB中用于存储数据的文件总共有两个部分
一是系统表空间文件，包括ibdata1 ibdata2
等文件，其中存储了InnoDB系统信息和用户数
据库表数据和索引，是所有表公用的。 当打开
innodb_file_per_table选项时，.ibd文件就是
每一个表独有的表空间，文件存储了当前表的
数据和相关的索引数据

如何存储记录
====

与现有的大多数存储引擎一样，InnoDB使用页作
为磁盘管理的最小单位；数据在InnoDB存储引擎
中都是按行存储的，每个16kb大小的页中可以
存放2-200行的记录

行溢出数据
====

当InnoDB使用Compact或者Redundant格式存储
极长的varchar或者blob这类对象时，并不会直接
将所有的内容都存放在数据页节点中，而是将行
数据中的前768个字节存储在数据页中，后面会
通过偏移量指向溢出页。但是当我们使用新的
行记录格式Compressed或者Dynamic时都只会
在行记录中保存20个字节的指针，实际的数据
都会存放在溢出页中。  当然在实际存储中，可
能对不同长度的text和blob列进行优化

数据页结构
====

页时InnoDB存储引擎管理数据的最小磁盘单位
而B-Tree节点就是实际存放表中数据的页面
每个页面包含七个部分： 每个页中包含两队
header/trailer：内部的page header/page 
directory关心的是页额状态信息，而fil header
/fil trailer关心的是记录页的头信息。 在
页的头部和尾部之间就是用户记录和空闲空间
每一个数据页中都包含Infimum和supremum这
两个虚拟的记录(可以理解为占位符)，infimum
记录是比该页中任何主键值都要小的值，
supremum是该页中最大值

Infimum|Row|Row|Row|Row|Row|Supremum
Use Records就是整个页面中真正用于存放行
记录的部分，而Free Space就是空余空间，它
是一个链表的数据结构，为了保证插入和删除
效率，整个页面并不会按照主键顺序对所有记录
进行排序，它会自动从左侧向右寻找空白节点
进行插入，行记录在物理存储上并不是按照
顺序的，它们之间的顺序是由next_record
指针控制的。

B+树在查找对应的记录时，并不会直接从树中
找出对应的行记录，它只能获取记录所在的页
将整个页加载到内存中，再通过page directory
中存储稀疏索引和n_owned、next_record属性
去除对应的记录，不过因为这已操作是在内存
中进行的，所以通常会忽略这部分查找的耗时

索引
====

索引是存储引擎能够快速定位记录的秘密武器
对于提升数据库的性能、减轻数据库服务器的
负担有着非常重要的作用： 索引优化是对查询
性能优化的最有效手段，能够轻松地将查询的
性能提高几个数量级

索引的数据结构
=====

InnoDB存储引擎 在绝大多数情况下使用B+树
建立索引，这是关系型数据库中查找最为常用
和有效索引，但是B+树索引并不能找到一个给定
键对应的具体值，它只能找到数据行对应的页
然后数据库把整个页读入到内存中，并在内存中
查找具体的数据行

B+树是平衡树，它查找任意节点所耗费的时间
都是相同的，比较的次数就是B+树的高度

聚集索引和辅助索引
=====
二者之间最大区别就是聚集索引中存放着一条
行记录的全部信息，而辅助索引中只包含索引
列和一个用于查找对应行记录的书签

聚集索引
======

InnoDB存储引擎中的表都是使用索引组织的，
也就是按照键的顺序存放；聚集索引就是按照
表中主键的顺序够贱一颗B+树，并在叶节点中
存放表中的行记录数据
create table users(
	id int not null,
	first_name varchar(20) not null,
	last_name varchar(20) not null,
	age int not null,
	primary key(id),
	key(last_name, first_name, age)
	key(first_name)
);
以上sql在数据库中创建一张表，B+树就会使用
ID作为索引的键，并在叶子节点中存储一条记录
中的所有信息。
聚集索引与表的物理存储方式有着非常密切的关
系，所有正常的表应该有且仅有一个聚集索引
(绝大部分情况下都是主键)表中的所有行记录
数据都是按照聚集索引的顺序存放的。

辅助索引
======

数据库将所有的非聚集索引都划分为辅助索引
辅助索引也是通过B+树实现的，但是它的叶节点
并不包含行记录的全部数据，仅包含索引中的
所有键和一个用于查找对应行记录的书签，在
InnoDB中这个书签就是当前记录的主键
辅助索引的存储并不会影响聚集索引，因为聚集
所有构成的B+树是数据实际存储的形式，而辅助
索引只用于加速数据的查找，所以一张表上往往
有多个辅助索引以此来提升数据库的性能。
如果在表users中存在一个辅助索引first_name
age，按照first_name,age的字母顺序对表中的
数据进行排序，当查找主键时，再通过聚集索引
获取到整条行记录
select * from users where first_name = 'xx'
and age <= 10
通过辅助运输查找找对应的主键，然后在聚集
索引中使用主键获取对应的行记录，这也是通常
情况下行记录的查找方式

锁
=====

锁一般分为乐观锁和悲观锁两种，InnoDB存储
引擎中使用的就是悲观锁，而按照锁的粒度划分
也分为行锁和表锁

并发控制机制
======

1、乐观锁是一种思想，其实并不是一种真正的
锁，它会先尝试对资源进行修改，在写回时判断
资源是否进行了改变，如果没有发生改变就写
回，否则就会进行重试，在整个的执行过程中
其实都没有对数据库进行加锁
2、悲观锁就是一种真正的锁，它会获取资源前
进行加锁，确保同一时刻只有有限的线程能够
访问该资源，其他想要尝试获取资源的操作都
会进入等待状态，知道该线程完成了对资源的
操作并且释放了锁后，其他线程才能重新操作
资源
乐观锁不会存在死锁的问题，但是由于更新后验
证，所以当冲突频率和重试成本较高时更推荐
使用悲观锁，而需要非常高的响应速度并且并发
量非常大的时候使用乐观锁就能较好的解决问题

锁的分类
======

对数据的操作其实只有两种，也就是读和写，
而数据库在时限锁时，也会对这两种操作使用
不同的锁；InnoDB时限了标准的行级锁，也就是
共享锁和互斥锁
共享锁：允许事务对一条行数据进行读取
互斥锁：允许事务对一条行数据进行删除或更新
所有可以在数据库中并行读，但只能串行写，
只有这样才能保证不会发生线程竞争，实现线程
安全

锁的粒度
======

意向共享锁：事务想要在获得表中某些记录的
共享锁，需要在表上先加意向共享锁
意向互斥锁:事务想要在获得表中某些记录的
互斥锁，需要在表上先加意向互斥锁
举个例子： 如果每一意向锁，当已经有人使用
行锁对表中的某一行进行修改时，如果另外一个
请求要对全表进行修改，那么就需要对所有的行
是否被锁定进行扫描，在这种情况下，效率是
非常低的。不过在引入意向锁之后，但有人使用
行锁对表中的某一行进行修改之前，会先为表添
加意向互斥锁，再为行记录添加互斥锁，在这
时如果有人尝试对权标进行修改就不需要判断
表中的每一行数据是否被加锁了，只需要通过
等待意向互斥锁被释放就可以了

隔离级别
=====

read uncommited：使用查询语句不会加锁，但
可能会读到未提交的行
read commited：只对记录加记录锁，而不会在
记录之间加间隙锁，所以运行新的记录插入到被
锁定记录的附件，所以再多次使用查询语句是，
可能得到不同的结果
repeatable read：多次读取同一范围的数据会
返回第一次查询的快照，不会返回不同的数据行
但是可能发生幻读
serializable：InnoDB隐式将全部的查询语句
加上共享锁，解决幻读的问题。
MySQL默认事务隔离级别就是repeatable read
但是它通过next-key锁也能够在某种程度上
解决幻读的问题