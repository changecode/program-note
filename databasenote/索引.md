索引
===

B+树如下图
http://tech.meituan.com/img/mysql_index/btree.jpg

B+树说明
====

浅蓝色的块称之为一个磁盘块，可以看到每
个磁盘块包含几个数据项(深蓝色所示)和
指针(黄色所示)，如磁盘块1包含数据项17和
35，包含指针P1 P2 P3,P1表示小于17的磁盘
块，P2表示在17和35之间的磁盘块，P3表示
大于35的磁盘块。真实的数据存在于叶子节
点即3 5 9 10 13 15 28 29 36 60 75 79 
90 99。非叶子节点不存储真实的数据，只
存储指引搜索方向的数据项，如17 35并不
真实存在于数据表中


B+树的查找过程
====

如果要查找数据项29，那么首先会把磁盘块
1由磁盘加载到内存，此时发了一次IO，在
内存中用二分法查找确定29在17和35之间，
锁定磁盘块1的P2指针，内存时间因为非常
短可以忽略不计，通过磁盘块1的P2指针的
磁盘地址把磁盘块3由磁盘加载到内存，发生
第二次IO，29在26和30之间，锁定磁盘块3的
P2的指针，通过指针加载磁盘块8到内存，发
生第三次IO，同时内存中做二分查找找到29
结束查询，总计三次IO。真实的情况时，
三层的B+树可以表示上百万的数据，如果上
百万的数据查找只需要三次IO，性能提高将
是巨大的，如果没有索引，每个数据项都要
发生一次IO，那么总计需要百万次的IO


B+树的性质
====

1、通过上面的分析，知道IO次数取决于B+
树的高度h, 假设当前数据表的数据为N，每
个磁盘块的数据项的数据是m,则有h=log(
m+1)N, 当数据量N一定的情况下，m越大，h
越小；而m= 磁盘块的大小 / 数据项的大小
磁盘块的大小也就是一个数据页的大小，是
固定的，如果数据项占的空间越小，数据项
的数量越多，树的高度越低。这就是为什么
每个数据项即索引字段要尽量小，比如int
占4字节要比bigint 8字节少一半。这也是
B+树要求把真实的数据放到叶子节点而不是
内层节点，一旦放到内层节点，磁盘块的
数据项会大幅度下降，导致树增高。当数据
项等于1时将会退化成线性表

2、当B+树的数据项是复合的数据结构，比如
(name,age,sex)的时候，B+树是按照从左往
右的顺序来建立搜索树的，比如当(张三，20，F)这样的数据来检索的时候，B+
树会优先比较name来确定下一步的所搜方向
如果name相同再依次比较age和sex。最后得
到检索的数据； 但当(20, F)这样的没有
name的数据来时，B+树不知道下一步该查
哪个节点，因为建立搜索树的时候name就是
第一个比较因子，必须要先根据name来搜索
才能知道下一步去哪里查询。比如当(张三
,F)这样的数据来检索时，B+树可以用name
来指定搜索方向，但下一个字段age的缺失，
所以只能把名字等于张三的数据都找到，然
后再匹配相比是F的数据了  索引的原则是
最左匹配


建索引的几大原则
====

1、 最左前缀匹配原则，MySQL会一直向右
知道遇到范围查询(> < between like)就
停止匹配，比如a=1 and b = 2 and c > 3
and d = 4 如果建立(a,b,c,d)顺序的索引，
d是用不到索引的，如果建立(a,b,d,c)索引
则都可以用到，a b d的顺序可以任意调整

2、= 和 in 可以乱序 比如 a = 1 and b = 
2 and c = 3 建立(a b c)索引可以任意顺序
MySQL的查询优化器会帮你优化成索引可以
识别的形式

3、尽量选择区分度高的列作为索引，区分度
的公式是 count(distinct col) / count(*)
表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些
状态、性别字段可能在大数据面前区分度就
是0， 一般需要join的字段要求在0.1以上
即平均1条扫描10条记录

4、索引列不能参与计算，保持列干净，比
如 from_unixtime(create_time) = '2010
-12-12' 就不能使用到索引。 应该写成
create_time = unit_timestamp('2010-1
2-12')

5、尽量的扩展索引，不要新建索引，比如
表中已经有a的索引，现在要加(a b)的索引
那么只需要修改原来的索引即可
